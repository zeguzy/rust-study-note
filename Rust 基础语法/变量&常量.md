# 变量 & 常量

Rust 相较于 javaScript / java / python 等语言，特点是 强类型静态语言，变量类型在编译时确定，并且不能改变。

## 变量

- 并且声明的变量 如果不使用 mut修饰，那么它是不可变的，如果尝试修改它，会在编译阶段报错。
- 如果尝试 赋值其他类型的值，那么也 会报错。

```rust
fn main() {
    let a = 1;
    println!("a = {}", a);
    // a = 2; // error: cannot assign twice to immutable variable `a`

    let mut b = 2;
    b = 3
    // b = "dfdf" // error: cannot assign `&str` (UTF-8 string) to `i32` (integer)

}
```

## 常量

- 常量使用 const 关键字声明，并且必须注明类型
- 编译时确定，不可改变
- 常量可在任何作用域中声明，包括全局作用域

```rust
fn main() {
    const MAX_POINTS: u32 = 100_000;
}
```


## 变量遮蔽

- 变量遮蔽允许我们重新使用变量名，但新的变量与旧的变量没有任何关系，新的变量是新的内存空间。（这个好！！！， 不用那么为取名困扰了）

```rust
fn main {
    let mut str = "hello";
    println!("str = {}", str);

    let str = "world"; //不用在为 world 取个名字了，此时和 上面的str 已经不相干了
    println!("str = {}", str);
}
```


### 总结

- Rust 的变量具有 默认不可变 、强类型、常量会被编译、类型不可改变，的特点，体现了 Rust 的设计哲学：安全、性能、并发。
- 同时 还提供了 类型遮蔽的特性， 提高了语言的简洁性。


### AI 补充 

你的总结非常到位，涵盖了Rust中变量和常量的关键特点。这里只是补充一些额外的细节和知识点：

#### 变量遮蔽（Shadowing）

- 遮蔽与可变性：变量遮蔽与可变性是两个不同的概念。即使原始变量是可变的，遮蔽它也会创建一个全新的、独立的数据绑定。
- 用途：遮蔽通常用于改变变量的类型或将其重用，这在处理函数返回值或进行模式匹配时特别有用。 (这个用途我没有get到，后面学模式匹配和处理函数返回值时注意一下)

#### 类型推断
- 编译时推断：虽然Rust是强类型语言，但它也支持类型推断。在大多数情况下，编译器能够根据赋值推断变量的类型，无需显式声明。
- 类型注解：尽管类型推断很方便，但在某些情况下，如函数参数或实现接口时，仍需要显式提供类型注解。

#### 作用域和生命周期
- 作用域：变量的作用域决定了它的可见性和生命周期。在Rust中，变量在离开其作用域后就会被.drop。
- 生命周期：对于更复杂的情况，如引用，Rust的生命周期注解确保所有引用都是有效的。

#### 字面量
- 数字字面量：Rust支持不同的数字字面量格式，包括标准、十六进制、八进制和二进制表示法。
- 字符串字面量：字符串字面量是UTF-8编码的字符串，可以直接包含在代码中。

#### 常量的限制
- 表达式限制：常量必须是一个常量表达式，这意味着它们的值在编译时就能确定，不能包含运行时计算的结果。

在Rust中，几乎所有的代码都是表达式，这与其他一些语言（如C或Java）中的语句和表达式的区别有所不同。理解表达式在Rust中的重要性，对于编写高效和简洁的代码非常关键。如果你有任何疑问或需要进一步的解释，请随时告诉我！


